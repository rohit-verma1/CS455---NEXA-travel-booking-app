from rest_framework import status, generics
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from drf_spectacular.utils import extend_schema

from .serializers import AgentQuerySerializer, BookingResponseSerializer, TripPlanResponseSerializer,SmartFilterLLMResponseSerializer,SmartPromptSerializer
from .utils import BookingAgent, TripPlanner
from django.conf import settings
import google.generativeai as genai
from rest_framework.permissions import AllowAny
import json
import re
class AgentQueryView(generics.GenericAPIView):
    serializer_class = AgentQuerySerializer
    permission_classes = [IsAuthenticated]

    @extend_schema(
        summary="Submit a Natural Language Query to the AI Booking Agent",
        description="Accepts a natural language query and returns booking options generated by Gemini AI.",
        request=AgentQuerySerializer,
        responses={200: BookingResponseSerializer}
    )
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        query = serializer.validated_data['query']

        try:
            # ‚úÖ FIX 1: The updated BookingAgent no longer needs `auth_token`
            # (since it uses Django ORM, not HTTP requests)
            agent = BookingAgent()

            # Execute the agent logic
            results = agent.execute(query)

            # ‚úÖ FIX 2: Gracefully handle structured error dicts
            if isinstance(results, dict) and 'error' in results:
                return Response({'error': results['error']}, status=status.HTTP_400_BAD_REQUEST)

            response_data = {'results': results}
            print(response_data)
            return Response(response_data, status=status.HTTP_200_OK)

        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            # Optional: Log this for debugging
            print(f"[Agent Error] {e}")
            return Response({'error': 'An unexpected server error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
class TripPlannerView(generics.GenericAPIView):
    serializer_class = AgentQuerySerializer
    permission_classes = [IsAuthenticated]

    @extend_schema(
        summary="Plan a Full Trip (AI-Generated)",
        description="Plans a trip with transport, expenses, and day-wise itinerary.",
        request=AgentQuerySerializer,
        responses={200: TripPlanResponseSerializer},
    )
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        query = serializer.validated_data["query"]

        planner = TripPlanner()
        result = planner.plan_trip(query)

        if "error" in result:
            return Response(result, status=status.HTTP_400_BAD_REQUEST)

        return Response(result, status=status.HTTP_200_OK)

class SmartFilterLLMView(generics.GenericAPIView):
    """
    Converts a natural language filter prompt into structured filter fields.
    """
    serializer_class = SmartPromptSerializer
    permission_classes = [AllowAny]

    @extend_schema(
        summary="LLM Smart Filter Parser",
        description="Uses Gemini to parse natural language filters into structured JSON fields.",
        request=SmartPromptSerializer,
        responses={200: SmartFilterLLMResponseSerializer},
    )
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user_prompt = serializer.validated_data["smart_prompt"]

        # Configure Gemini
        if not settings.GEMINI_API_KEY:
            return Response(
                {"error": "GEMINI_API_KEY is not configured."},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )
        genai.configure(api_key=settings.GEMINI_API_KEY)
        model = genai.GenerativeModel("gemini-2.5-flash")

        # Prompt design
        prompt = f"""
        You are a travel filter parser.
        Convert the following natural-language user filter request into structured JSON fields
        for flights, trains, or buses.

        Example inputs:
        - "I want flights under ‚Çπ5000 with no stops before 6AM on Indigo"
        - "Show me 1-stop flights between ‚Çπ7000 and ‚Çπ12000 departing after 6PM"
        - "Trains under ‚Çπ3000 taking less than 5 hours"

        Always respond in **pure JSON only**, no text or commentary.

        Output schema example:
        {{
          "stops": "non-stop" | "1-stop" | "2-stop" | null,
          "price_min": <int or null>,
          "price_max": <int or null>,
          "duration_min": <int or null>,
          "duration_max": <int or null> (in minutes),
          "departure_time": "before_6am" | "6am_12pm" | "12pm_6pm" | "after_6pm" | null,
          "arrival_time": same as above or null,
          "airlines": ["Indigo", "Air India"] or []
        }}

        User query:
        \"\"\"{user_prompt}\"\"\"
        """

        try:
            response = model.generate_content(prompt)
            text = response.text if hasattr(response, "text") else str(response)
            # --- üßπ CLEAN THE OUTPUT ---
            # Remove Markdown code fences like ```json ... ```
            cleaned_text = re.sub(r"```(?:json)?", "", text).strip()

            # Extract the first valid JSON object using regex
            match = re.search(r"\{[\s\S]*\}", cleaned_text)
            if match:
                cleaned_text = match.group(0)

            # Attempt to parse cleaned text
            try:
                parsed = json.loads(cleaned_text)
            except json.JSONDecodeError:
                print("‚ö†Ô∏è JSONDecodeError: Using fallback default")
                parsed = {
                    "stops": None,
                    "price_min": None,
                    "price_max": None,
                    "duration_min": None,
                    "duration_max": None,
                    "departure_time": None,
                    "arrival_time": None,
                    "airlines": [],
                }

            # ‚úÖ Validate + return response
            output_serializer = SmartFilterLLMResponseSerializer(parsed)
            return Response(output_serializer.data, status=status.HTTP_200_OK)

        except Exception as e:
            return Response(
                {"error": f"LLM parsing failed: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )